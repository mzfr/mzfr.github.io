<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Using Github Action for recon | mzfr's Blog</title><meta name=keywords content="recon"><meta name=description content="Let&rsquo;s see if it&rsquo;s possible to use GitHub action for recon"><meta name=author content><link rel=canonical href=https://blog.mzfr.me/posts/2021-01-23-github-action-for-recon/><link href=https://blog.mzfr.me/assets/css/stylesheet.min.5baf04febe2267df4c63da0fdc6ddc3ba4a7896651a0ef2a638126272da2948d.css integrity="sha256-W68E/r4iZ99MY9oP3G3cO6SniWZRoO8qY4EmJy2ilI0=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.mzfr.me/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.mzfr.me/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.mzfr.me/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.mzfr.me/apple-touch-icon.png><link rel=mask-icon href=https://blog.mzfr.me/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.83.1"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/styles/gruvbox-dark.min.css integrity="sha512-H+WY7zsI0kQwkbYE+yp/9vg/UzpiyuKERzpxOaGwKCc7iFoNpi0h3mQ4GpZMO9lDaVzc1xjD3e6g/UMuUlOicg==" crossorigin=anonymous><script data-ad-client=ca-pub-1450519482686010 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-147356794-1','auto'),ga('send','pageview'))</script><script async src=https://www.google-analytics.com/analytics.js></script><meta property="og:title" content="Using Github Action for recon"><meta property="og:description" content="Let&rsquo;s see if it&rsquo;s possible to use GitHub action for recon"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.mzfr.me/posts/2021-01-23-github-action-for-recon/"><meta property="article:published_time" content="2021-01-23T00:00:00+00:00"><meta property="article:modified_time" content="2021-01-23T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Using Github Action for recon"><meta name=twitter:description content="Let&rsquo;s see if it&rsquo;s possible to use GitHub action for recon"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Using Github Action for recon","name":"Using Github Action for recon","description":"Let\u0026amp;rsquo;s see if it\u0026amp;rsquo;s possible to use GitHub action for recon","keywords":["recon"],"articleBody":"In this blog post, I will talk a bit about how I use Github Actions for simple recon stuff. If you already know what Github Actions are and doesnâ€™t want to read the backstory then skip to the How to Setup Github Action\nBack Story As I wrote in my year in review blog post, initially when I started doing bug-bounty I mostly focused on Android applications but with time I realized that just focusing on the android application isnâ€™t going to help me much. Because most of the time programs have usually 1 or 2 android apps in scope and those apps only sometimes tend to give bug that is not duplicated. So at the beginning of this year, I decided to expand my hunting scope and try to find bugs on web applications as well.\nNow if you tend to be doing bug-bounty on websites/web applications you must have heard all the great hunters say things like recon is important or P1 in 1 minute just by recon(ðŸ˜‚). And then you will see that most of the task in the recon has to be automated, emphasis on the word has because recon process has certain steps which we try to follow on all the programs/targets. So I decided to make my own recon setup, mine is not a very evolved one or something big but simple things.\nBasic recon flow Initially, I had written a small script which does the following: - Store all the domains in the scope to a file called scope.txt - Run multiple subdomain enumeration tools like amass, subfinder etc on scope.txt, merge the output from all and give subdomains.txt - If subdomains.txt already exists then compare the new one with the old one and generate an alert if any new subdomain found. - Run massdns and httpx on that file.\nI came up with this whole idea after reading lots of blog posts about recon methodologies. Almost everyone recommends having a VPS(not compulsory but helps). So what I thought was that I could set up this small script on cronjob on a VPS and then just wait for it to generate alerts. But thatâ€™s when I thought to myself why not do this with GitHub actions\nWhat is Github Actions?\nGitHub Actions makes it easy to automate all your software workflows, now with world-class CI/CD. Build, test, and deploy your code right from GitHub. Make code reviews, branch management, and issue triaging work the way you want.\nIn simpler words, it is a better replacement for travis. If you have a GitHub project and you want to run a linter check or tests on every pull request to make sure nothing breaks you can setup a Github Action which will do the same.\n Now even though Github Action is made for simpler things like running tests/linters it can do a lot of powerful stuff because, in the end, it is actually a Virtual machine. And things that can run on a VM(or even in a normal setup) can be executed via Github Action.\nGithub Actions for recon Letâ€™s look at this with an example, say you want to run subfinder on a file called scope.txt having example.com in it. And this scope.txt is present in your Github repo.\non: [push] # This is a trigger https://docs.github.com/en/actions/reference/events-that-trigger-workflows jobs: build: # The OS for which will be used. # You can specify the exact version if you want. runs-on: ubuntu-latest # From here we just define all the steps that we have to do. steps: - name: Checkout Repo uses: actions/checkout@master # Install golang - name: Setup golang uses: actions/setup-go@v2 with: go-version: '^1.14.14' - name: Setup go tools run: |go version GO111MODULE=on go get -v github.com/projectdiscovery/subfinder/v2/cmd/subfinder - name: Run Subfinder run: subfinder -silent -dL scope.txt -o subfinder.txt - name: Save domains run: |git config --local user.email \"myemail@example.com\" git config --local user.name \"MY USERNAME\" git add --all git commit -m \"Add Subdomains.txt\" - name: Push changes uses: ad-m/github-push-action@master with: github_token: ${{ secrets.TOKEN }} I have written some comments within the example above. The important thing for us is the steps these are basic things that we are asking the Github Actions to do inside the VM.\nBelow Iâ€™ve tried to explain all the steps in a bit detail:\n Checkout your Repository file  - name: Checkout Repo uses: actions/checkout@master This is a predefined action, actions/checkout. This will basically copy all the files of your GitHub repository to the VM, meaning if you had the file called scope.txt in your repository then it will make a file named scope.txt in the /home/ directory of the VM(the one which will run our job).\n Setup golang  Since subfinder is written in golang we need to install go in the VM.\n- name: Setup golang uses: actions/setup-go@v2 with: go-version: '^1.14.14' The installation page for subfinder says that the go version 1.14+ is required so we are here installing 1.14.14. By the way, this actions/setup-go is also a predefined GitHub action which you can find here.\n Install subfinder and run it  - name: Setup go tools run: |go version GO111MODULE=on go get -v github.com/projectdiscovery/subfinder/v2/cmd/subfinder Till this step, we have to install subfinder in our environment. So if you have to think in the sense of a normal file system you can think of it like, there is a VM in which there is a /home directory inside that directory we have a directory named go(this is assuming all the go packages are being installed in a directory named go/). And in that, we have installed a tool called subfinder. Also in the /home directory is a file called scope.txt.\nNow itâ€™s time for us to run subfinder\n- name: Run Subfinder run: subfinder -silent -dL scope.txt -o subfinder.txt This will execute the command on the VM and will produce the file with all the subdomains in it.\n Push back the file to the repo  Now once the subfinder generates the output you obviously would like to see the output. And the best option is to just push the files back to your repo.\n- name: Save domains # if you don't want to push all the files back then you can also mention it like `git add subdomains.txt` run: |git config --local user.email \"myemail@example.com\" git config --local user.name \"MY USERNAME\" git add --all git commit -m \"Add Subdomains.txt\" - name: Push changes uses: ad-m/github-push-action@master with: github_token: ${{ secrets.TOKEN }} These two steps are basically adding all the newly generated files i.e subdomains.txt to the GitHub repo and then pushing that file. This is similar to how normal add, commit, push works in git.\nIf you notice the last line it says secrets.TOKEN this is a secret token that you can generate from your GitHub settings. To learn how to generate and add the token please read this.\n This was the basics of how you can run a simple command using Github actions. Now before we talk about how do I do complex stuff I would like to talk about the limitations of this setup.\nLimitations Since Github Action wasnâ€™t meant for Bug Hunting or any kind of big task it has its own limitations. The ones that are pretty important are:\n  Each job in a workflow can run for up to 6 hours of execution time.\n Hitting the time limit will result in failure of the job This means we canâ€™t run a masscan on a subnet which might take more than 6 hours    You can execute up to 1000 API requests in an hour across all actions within a repository\n Only 1000 API requests are allowed in an hour. So if you want to do Github Dorking for subdomains then you need to find an efficient way to get more data in every single request.    You get only certain minutes of Github Action per month.\n For a PRO GitHub user you get 3000 minutes i.e 50 hours of Github Action per month For a normal user I think the limit is around 2000 minutes per month    Other than that there are few more limitations and you can read about those here\nNow the last limitation about the minutes per month is the only thing that might sound a bit problematic but itâ€™s actually not. I did some testing and found out that if you have 5 targets(websites) in your scope.txt and you run amass + subfinder + findomain then pass the output to massdns and httpx then the whole job gets completed in under 2 minutes(never exceeds 2 minutes).\nIf we do the maths, In a month there are ~730 hours, say you run the job every 5th hour that means the job run 146 times in a month. And assuming Every job took 2 minutes that will be a total of 292 minutes. And as a normal user, you had 2000 minutes so that means youâ€™ll still have ~1708 minutes of Github Actions. Now to fully drain out the limit you can run a lot of jobs at various intervals. Some of them are given below:\n Run a 2-minute job every 44 minutes and youâ€™ll have ~10 minutes left in the quota by the end of a month. Run a 27-minute job every 10 hours and youâ€™ll have ~21 minutes left in the quota by the end of a month.  If I did the math wrong Please let me know ðŸ˜‚\nWell, these were just some stats but the whole point is that you can still run quite some tools on GitHub Actions.\nSuggestion on the process   If any of you decide to try this out then I would recommend setting up a job or maybe multiple jobs with the schedule.\n See Githubâ€™s doc on how to schedule events    Donâ€™t run anything big like masscan/nmap or ffuf with a very large list etc\n  Instead of adding steps for every command make a small bash script and run them after the setup steps.\n  Ex:\n- name: Setup go tools run: |go version GO111MODULE=on go get -v github.com/projectdiscovery/subfinder/v2/cmd/subfinder GO111MODULE=on go get -v github.com/projectdiscovery/httpx/cmd/httpx - name: Subdomain enumeration run: bash recon.sh Inside the recon.sh you can use all the tools or the logic that you want in your recon process.\nNOTE: Donâ€™t forget to install all the tools before using them in the script\n Use webhooks for notification. Like within the script add a curl command to send an alert if something happened.  Ex: Say you want to be notified at the moment you get the new subdomains so you can add something\ncurl -X POST -H 'Content-type: application/json' --data '{\"text\":\"Found new Subdomains\"}' YOUR_WEBHOOK_URL This is just an example of if you made a bash script.\nBenefits of GitHub Actions I mean a lot of you might already have a perfect setup on your VPS/home servers but if you are just starting out then there can be quite a few benefits with this setup.\n  Setting Github Action is pretty easy\n Might look difficult but itâ€™s actually not    No need for logging your stuff.\n If you set up a cron job on VPS youâ€™ll have to keep the logs of that cron, in case it might fail sometime that will help in debugging in your script/code  I know cron logs can be found in /var/log/syslog but I am saying this just for the sake of argument.   But with Github Action if any of the steps fail it will show the detailed error of why the failure occurred.    No cost\n You donâ€™t have to pay any monthly charge, you can do this even without being PRO Github User    Data availability\n You can install the Github Android/iOS app and then keep the track of all the data that if being found Here you can argue that we can do the same by sending the data via Webhooks on slack  But as a counter-argument, I would say if you run ffuf with -mc all -ac then there are chances of having loads of data so the best option is to just keep it in a file on a repo ðŸ˜„ðŸ˜„      Conclusion In my opinion, using Github Actions is really nice for doing recon(to some limits). I have my private setup which does the recon stuff for me and then I have another cronjob that pulls the data from the repo to my system where I can analyze the data properly. I also had an idea about analysis of the data i.e you can have another script or maybe include this in your recon script which converts the output of all the tools to markdown and then pushes the changes this way all the data will be beautified and much easy to go through.\nThis is just one of the idea, the possibilities are infinite here. In the end, Iâ€™d just say that if you havenâ€™t tried something like this then itâ€™s definitely worth a try. And if you end up doing something cool with this then let me know.\nAlso if you find any problem with all the mathematics that I did then please let me know ðŸ˜„.\n Thanks for reading, Feedback is always appreciated.\nYou can follow me on @0xmzfr.\n","wordCount":"2184","inLanguage":"en","datePublished":"2021-01-23T00:00:00Z","dateModified":"2021-01-23T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.mzfr.me/posts/2021-01-23-github-action-for-recon/"},"publisher":{"@type":"Organization","name":"mzfr's Blog","logo":{"@type":"ImageObject","url":"https://blog.mzfr.me/favicon.ico"}}}</script></head><body><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>.theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://blog.mzfr.me accesskey=h>mzfr's Blog</a>
<span class=logo-switches><span class=theme-toggle><a id=theme-toggle accesskey=t><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></a></span></span></div><ul class=menu id=menu onscroll=menu_on_scroll()><li><a href=https://blog.mzfr.me/><span>Home</span></a></li><li><a href=https://blog.mzfr.me/about/><span>About</span></a></li><li><a href=https://github.com/mzfr/notes/wiki/><span>Notes</span></a></li><li><a href=https://blog.mzfr.me/ctf/><span>Writeups</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Using Github Action for recon</h1><div class=post-meta>January 23, 2021&nbsp;Â·&nbsp;11 min</div></header><div class=post-content><p>In this blog post, I will talk a bit about how I use Github Actions for simple recon stuff. If you already know what Github Actions are and doesn&rsquo;t want to read the backstory then skip to the <a href=#github-actions-for-recon>How to Setup Github Action</a></p><h2 id=back-story>Back Story<a hidden class=anchor aria-hidden=true href=#back-story>#</a></h2><p>As I wrote in my <a href=https://blog.mzfr.me/posts/year-in-review-2020/>year in review</a> blog post, initially when I started doing bug-bounty I mostly focused on Android applications but with time I realized that just focusing on the android application isn&rsquo;t going to help me much. Because most of the time programs have usually 1 or 2 android apps in scope and those apps only sometimes tend to give bug that is not duplicated. So at the beginning of this year, I decided to expand my hunting scope and try to find bugs on web applications as well.</p><p>Now if you tend to be doing bug-bounty on websites/web applications you must have heard all the great hunters say things like <code>recon is important</code> or <code>P1 in 1 minute just by recon</code>(ðŸ˜‚). And then you will see that most of the task in the recon has to be automated, emphasis on the word <code>has</code> because recon process has certain steps which we try to follow on all the programs/targets. So I decided to make my own recon setup, mine is not a very evolved one or something big but simple things.</p><h3 id=basic-recon-flow>Basic recon flow<a hidden class=anchor aria-hidden=true href=#basic-recon-flow>#</a></h3><p>Initially, I had written a small script which does the following:
- Store all the domains in the scope to a file called <code>scope.txt</code>
- Run multiple subdomain enumeration tools like amass, subfinder etc on <code>scope.txt</code>, merge the output from all and give <code>subdomains.txt</code>
- If subdomains.txt already exists then compare the new one with the old one and generate an alert if any new subdomain found.
- Run massdns and httpx on that file.</p><p>I came up with this whole idea after reading lots of blog posts about recon methodologies. Almost everyone recommends having a VPS(not compulsory but helps). So what I thought was that I could set up this small script on cronjob on a VPS and then just wait for it to generate alerts. But that&rsquo;s when I thought to myself <code>why not do this with GitHub actions</code></p><p><strong>What is Github Actions?</strong></p><p>GitHub Actions makes it easy to automate all your software workflows, now with world-class CI/CD. Build, test, and deploy your code right from GitHub. Make code reviews, branch management, and issue triaging work the way you want.</p><p>In simpler words, it is a better replacement for <a href=https://travis-ci.org/><code>travis</code></a>. If you have a GitHub project and you want to run a <code>linter</code> check or <code>tests</code> on every pull request to make sure nothing breaks you can setup a Github Action which will do the same.</p><hr><p>Now even though Github Action is made for simpler things like running tests/linters it can do a lot of powerful stuff because, in the end, it is actually a Virtual machine. And things that can run on a VM(or even in a normal setup) can be executed via Github Action.</p><h2 id=github-actions-for-recon>Github Actions for recon<a hidden class=anchor aria-hidden=true href=#github-actions-for-recon>#</a></h2><p>Let&rsquo;s look at this with an example, say you want to run <a href=https://github.com/projectdiscovery/subfinder><code>subfinder</code></a> on a file called <code>scope.txt</code> having <code>example.com</code> in it. And this <code>scope.txt</code> is present in your Github repo.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=color:#f92672>on</span>: [<span style=color:#ae81ff>push]</span> <span style=color:#75715e># This is a trigger https://docs.github.com/en/actions/reference/events-that-trigger-workflows</span>

<span style=color:#f92672>jobs</span>:
  <span style=color:#f92672>build</span>:
  <span style=color:#75715e># The OS for which will be used.</span>
  <span style=color:#75715e># You can specify the exact version if you want.</span>
    <span style=color:#f92672>runs-on</span>: <span style=color:#ae81ff>ubuntu-latest</span>

    <span style=color:#75715e># From here we just define all the steps that we have to do.</span>
    <span style=color:#f92672>steps</span>:
      - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>Checkout Repo</span>
        <span style=color:#f92672>uses</span>: <span style=color:#ae81ff>actions/checkout@master</span>

      <span style=color:#75715e># Install golang</span>
      - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>Setup golang</span>
        <span style=color:#f92672>uses</span>: <span style=color:#ae81ff>actions/setup-go@v2</span>
        <span style=color:#f92672>with</span>:
          <span style=color:#f92672>go-version</span>: <span style=color:#e6db74>&#39;^1.14.14&#39;</span>

      - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>Setup go tools</span>
        <span style=color:#f92672>run</span>: |<span style=color:#e6db74>
</span><span style=color:#e6db74>          go version
</span><span style=color:#e6db74>          GO111MODULE=on go get -v github.com/projectdiscovery/subfinder/v2/cmd/subfinder</span>          

      - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>Run Subfinder</span>
        <span style=color:#f92672>run</span>: <span style=color:#ae81ff>subfinder -silent -dL scope.txt -o subfinder.txt</span>

      - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>Save domains</span>
        <span style=color:#f92672>run</span>: |<span style=color:#e6db74>
</span><span style=color:#e6db74>          git config --local user.email &#34;myemail@example.com&#34;
</span><span style=color:#e6db74>          git config --local user.name &#34;MY USERNAME&#34;
</span><span style=color:#e6db74>          git add --all
</span><span style=color:#e6db74>          git commit -m &#34;Add Subdomains.txt&#34;</span>          

      - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>Push changes</span>
        <span style=color:#f92672>uses</span>: <span style=color:#ae81ff>ad-m/github-push-action@master</span>
        <span style=color:#f92672>with</span>:
          <span style=color:#f92672>github_token</span>: <span style=color:#ae81ff>${{ secrets.TOKEN }}</span>

</code></pre></div><p>I have written some comments within the example above. The important thing for us is the <code>steps</code> these are basic things that we are asking the Github Actions to do inside the VM.</p><p>Below I&rsquo;ve tried to explain all the steps in a bit detail:</p><ul><li><strong>Checkout your Repository file</strong></li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>Checkout Repo</span>
    <span style=color:#f92672>uses</span>: <span style=color:#ae81ff>actions/checkout@master</span>
</code></pre></div><p>This is a predefined action, <a href=https://github.com/actions/checkout>actions/checkout</a>. This will basically copy all the files of your GitHub repository to the VM, meaning if you had the file called <code>scope.txt</code> in your repository then it will make a file named <code>scope.txt</code> in the <code>/home/</code> directory of the VM(the one which will run our job).</p><ul><li><strong>Setup golang</strong></li></ul><p>Since <code>subfinder</code> is written in <code>golang</code> we need to install go in the VM.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>Setup golang</span>
    <span style=color:#f92672>uses</span>: <span style=color:#ae81ff>actions/setup-go@v2</span>
    <span style=color:#f92672>with</span>:
        <span style=color:#f92672>go-version</span>: <span style=color:#e6db74>&#39;^1.14.14&#39;</span>
</code></pre></div><p>The installation page for <code>subfinder</code> says that the go version <code>1.14+</code> is required so we are here installing <code>1.14.14</code>. By the way, this <code>actions/setup-go</code> is also a predefined GitHub action which you can find <a href=https://github.com/actions/setup-go>here</a>.</p><ul><li><strong>Install subfinder and run it</strong></li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>Setup go tools</span>
  <span style=color:#f92672>run</span>: |<span style=color:#e6db74>
</span><span style=color:#e6db74>    go version
</span><span style=color:#e6db74>    GO111MODULE=on go get -v github.com/projectdiscovery/subfinder/v2/cmd/subfinder</span>    
</code></pre></div><p>Till this step, we have to install subfinder in our environment. So if you have to think in the sense of a <code>normal</code> file system you can think of it like, there is a VM in which there is a <code>/home</code> directory inside that directory we have a directory named <code>go</code>(this is assuming all the go packages are being installed in a directory named <code>go/</code>). And in that, we have installed a tool called <code>subfinder</code>. Also in the <code>/home</code> directory is a file called <code>scope.txt</code>.</p><p>Now it&rsquo;s time for us to run <code>subfinder</code></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>Run Subfinder</span>
  <span style=color:#f92672>run</span>: <span style=color:#ae81ff>subfinder -silent -dL scope.txt -o subfinder.txt</span>
</code></pre></div><p>This will execute the command on the VM and will produce the file with all the subdomains in it.</p><ul><li><strong>Push back the file to the repo</strong></li></ul><p>Now once the subfinder generates the output you obviously would like to see the output. And the best option is to just push the files back to your repo.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>Save domains</span>
    <span style=color:#75715e># if you don&#39;t want to push all the files back then you can also mention it like `git add subdomains.txt`</span>
    <span style=color:#f92672>run</span>: |<span style=color:#e6db74>
</span><span style=color:#e6db74>        git config --local user.email &#34;myemail@example.com&#34;
</span><span style=color:#e6db74>        git config --local user.name &#34;MY USERNAME&#34;
</span><span style=color:#e6db74>        git add --all
</span><span style=color:#e6db74>        git commit -m &#34;Add Subdomains.txt&#34;</span>        

- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>Push changes</span>
    <span style=color:#f92672>uses</span>: <span style=color:#ae81ff>ad-m/github-push-action@master</span>
    <span style=color:#f92672>with</span>:
        <span style=color:#f92672>github_token</span>: <span style=color:#ae81ff>${{ secrets.TOKEN }}</span>
</code></pre></div><p>These two steps are basically adding all the newly generated files i.e <code>subdomains.txt</code> to the GitHub repo and then pushing that file. This is similar to how normal <code>add, commit, push</code> works in git.</p><p>If you notice the last line it says <code>secrets.TOKEN</code> this is a secret token that you can generate from your GitHub settings. To learn how to generate and add the token please read <a href=https://docs.github.com/en/actions/reference/encrypted-secrets>this</a>.</p><hr><p>This was the basics of how you can run a simple command using Github actions. Now before we talk about how do I do complex stuff I would like to talk about the limitations of this setup.</p><h3 id=limitations>Limitations<a hidden class=anchor aria-hidden=true href=#limitations>#</a></h3><p>Since Github Action wasn&rsquo;t meant for Bug Hunting or any kind of big task it has its own limitations. The ones that are pretty important are:</p><ul><li><p>Each job in a workflow can run for up to 6 hours of execution time.</p><ul><li>Hitting the time limit will result in failure of the job</li><li>This means we can&rsquo;t run a masscan on a subnet which might take more than 6 hours</li></ul></li><li><p>You can execute up to 1000 API requests in an hour across all actions within a repository</p><ul><li>Only 1000 API requests are allowed in an hour.</li><li>So if you want to do Github Dorking for subdomains then you need to find an efficient way to get more data in every single request.</li></ul></li><li><p>You get only certain minutes of Github Action per month.</p><ul><li>For a PRO GitHub user you get 3000 minutes i.e 50 hours of Github Action per month</li><li>For a normal user I think the limit is around 2000 minutes per month</li></ul></li></ul><p>Other than that there are few more limitations and you can read about those <a href=https://docs.github.com/en/actions/reference/usage-limits-billing-and-administration>here</a></p><p>Now the last limitation about the <code>minutes per month</code> is the only thing that might sound a bit problematic but it&rsquo;s actually not. I did some testing and found out that if you have 5 targets(websites) in your <code>scope.txt</code> and you run <code>amass + subfinder + findomain</code> then pass the output to <code>massdns</code> and <code>httpx</code> then the whole job gets completed in under 2 minutes(never exceeds 2 minutes).</p><p>If we do the maths, In a month there are ~730 hours, say you run the job every 5th hour that means the job run <code>146</code> times in a month. And assuming Every job took 2 minutes that will be a total of <code>292</code> minutes. And as a normal user, you had 2000 minutes so that means you&rsquo;ll still have ~1708 minutes of Github Actions. Now to fully drain out the limit you can run a lot of jobs at various intervals. Some of them are given below:</p><ul><li>Run a 2-minute job every 44 minutes and you&rsquo;ll have ~10 minutes left in the quota by the end of a month.</li><li>Run a 27-minute job every 10 hours and you&rsquo;ll have ~21 minutes left in the quota by the end of a month.</li></ul><p><strong>If I did the math wrong Please let me know ðŸ˜‚</strong></p><p>Well, these were just some stats but the whole point is that you can still run quite some tools on GitHub Actions.</p><h3 id=suggestion-on-the-process>Suggestion on the process<a hidden class=anchor aria-hidden=true href=#suggestion-on-the-process>#</a></h3><ul><li><p>If any of you decide to try this out then I would recommend setting up a job or maybe multiple jobs with the schedule.</p><ul><li>See Github&rsquo;s doc on <a href=https://docs.github.com/en/actions/reference/events-that-trigger-workflows#scheduled-events>how to schedule events</a></li></ul></li><li><p>Don&rsquo;t run anything big like masscan/nmap or ffuf with a very large list etc</p></li><li><p>Instead of adding <code>steps</code> for every command make a small bash script and run them after the setup steps.</p></li></ul><p>Ex:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>Setup go tools</span>
<span style=color:#f92672>run</span>: |<span style=color:#e6db74>
</span><span style=color:#e6db74>    go version
</span><span style=color:#e6db74>    GO111MODULE=on go get -v github.com/projectdiscovery/subfinder/v2/cmd/subfinder
</span><span style=color:#e6db74>    GO111MODULE=on go get -v github.com/projectdiscovery/httpx/cmd/httpx</span>    

- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>Subdomain enumeration</span>
<span style=color:#f92672>run</span>: <span style=color:#ae81ff>bash recon.sh</span>
</code></pre></div><p>Inside the <code>recon.sh</code> you can use all the tools or the logic that you want in your recon process.</p><p><strong>NOTE</strong>: Don&rsquo;t forget to install all the tools before using them in the script</p><ul><li>Use webhooks for notification. Like within the script add a <code>curl</code> command to send an alert if something happened.</li></ul><p>Ex: Say you want to be notified at the moment you get the new subdomains so you can add something</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>curl -X POST -H <span style=color:#e6db74>&#39;Content-type: application/json&#39;</span> --data <span style=color:#e6db74>&#39;{&#34;text&#34;:&#34;Found new Subdomains&#34;}&#39;</span> YOUR_WEBHOOK_URL
</code></pre></div><p>This is just an example of if you made a bash script.</p><h3 id=benefits-of-github-actions>Benefits of GitHub Actions<a hidden class=anchor aria-hidden=true href=#benefits-of-github-actions>#</a></h3><p>I mean a lot of you might already have a perfect setup on your VPS/home servers but if you are just starting out then there can be quite a few benefits with this setup.</p><ul><li><p>Setting Github Action is pretty easy</p><ul><li>Might look difficult but it&rsquo;s actually not</li></ul></li><li><p>No need for logging your stuff.</p><ul><li>If you set up a cron job on VPS you&rsquo;ll have to keep the logs of that cron, in case it might fail sometime that will help in debugging in your script/code<ul><li>I know cron logs can be found in <code>/var/log/syslog</code> but I am saying this just for the sake of argument.</li></ul></li><li>But with Github Action if any of the steps fail it will show the detailed error of why the failure occurred.</li></ul></li><li><p>No cost</p><ul><li>You don&rsquo;t have to pay any monthly charge, you can do this even without being PRO Github User</li></ul></li><li><p>Data availability</p><ul><li>You can install the Github Android/iOS app and then keep the track of all the data that if being found</li><li>Here you can argue that we can do the same by sending the data via Webhooks on slack<ul><li>But as a counter-argument, I would say if you run ffuf with <code>-mc all -ac</code> then there are chances of having loads of data so the best option is to just keep it in a file on a repo ðŸ˜„ðŸ˜„</li></ul></li></ul></li></ul><h3 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h3><p>In my opinion, using Github Actions is really nice for doing recon(to some limits). I have my private setup which does the recon stuff for me and then I have another cronjob that pulls the data from the repo to my system where I can analyze the data properly. I also had an idea about analysis of the data i.e you can have another script or maybe include this in your recon script which converts the output of all the tools to <code>markdown</code> and then pushes the changes this way all the data will be beautified and much easy to go through.</p><p>This is just one of the idea, the possibilities are infinite here. In the end, I&rsquo;d just say that if you haven&rsquo;t tried something like this then it&rsquo;s definitely worth a try. And if you end up doing something cool with this then let me know.</p><p>Also if you find any problem with all the mathematics that I did then please let me know ðŸ˜„.</p><hr><p>Thanks for reading, Feedback is always appreciated.</p><p>You can follow me on <a href=https://twitter.com/0xmzfr>@0xmzfr</a>.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.mzfr.me/tags/recon>recon</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://blog.mzfr.me>mzfr's Blog</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><button class=top-link id=top-link type=button aria-label="go to top" title="Go to Top" accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6"><path d="M12 6H0l6-6z"/></svg></button>
<script defer src=https://blog.mzfr.me/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position"))};var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")},mybutton.onclick=function(){document.body.scrollTop=0,document.documentElement.scrollTop=0,window.location.hash=''};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft)}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>